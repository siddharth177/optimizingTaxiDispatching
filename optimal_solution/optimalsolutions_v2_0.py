# -*- coding: utf-8 -*-
"""OptimalSolutions v2.0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TbEu2VoXGwLUvK-BomfpckZhD-ZZ2EJy
"""

!pip install gurobipy

#test inputs
import pandas as pd
import numpy as np
import gurobipy
from gurobipy import Model, GRB, quicksum, tuplelist
from geopy.distance import great_circle
import math
import itertools
import random
import os
import shutil
from matplotlib import pyplot as plt
from copy import deepcopy

EAV_range = 200.0 #miles
avg_speed_NYC = 13.0 #mph
power_consumption_rate = 0.3 #kWh/mi
need_charging = 0.2 #SOC<20% range
charge_upto = 0.8 #charge upto 80%

max_pickup_time = 30.0 #minutes
max_pickup_dist = max_pickup_time*avg_speed_NYC/60 #miles
max_wait_time = 15.0
charging_power = 50.0 #kW

def trip_distance(long1, lat1, long2, lat2):
  GPS1 = (long1, lat1)
  GPS2 = (long2, lat2)
  return 1.4413*great_circle(GPS1, GPS2).miles + 0.1383 #miles

taxi = pd.read_csv('taxi_data.csv')
request = pd.read_csv('customer_trip_data.csv')

taxi_index = taxi.index.tolist()
request_index = request.index.tolist()
path = tuplelist(list(itertools.product(taxi_index, request_index)))
taxi = taxi.to_dict(orient="index")
request = request.to_dict(orient="index")

#pickup distance
pickup_distance = pd.DataFrame(index=taxi_index, columns=request_index)
pickup_distance = pickup_distance.to_dict(orient="index")
for each_taxi in taxi_index:
  for each_request in request_index:
    taxi_GPS = (taxi[each_taxi]['taxi_longitude'], taxi[each_taxi]['taxi_lattitude'])
    request_GPS = (request[each_request]['pickup_longitude'], request[each_request]['pickup_lattitude'])
    pickup_distance[each_taxi][each_request] = 1.4413*great_circle(taxi_GPS, request_GPS).miles + 0.1383 #miles

#pickup time
pickup_time_in_mins = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_time_in_mins[each_taxi][each_request] = int(math.ceil((pickup_distance[each_taxi][each_request]/avg_speed_NYC) * 60))
    
#pickup time + customer_waiting_time(mins)
delay_time_in_mins = deepcopy(pickup_time_in_mins)
for each_taxi in taxi_index:
  for each_request in request_index:
    delay_time_in_mins[each_taxi][each_request] = (pickup_time_in_mins[each_taxi][each_request]
            + request[each_request]['customer_waiting_time(mins)'])
    
#pickup distance + occupied distance dictionary
pickup_occupied_distance = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_occupied_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance']
            
#pickup distance + occupied distance + charging distance dictionary
pickup_occupied_CS_distance = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_occupied_CS_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance'] + request[each_request]['CS_distance']

#customer waiting time
eta = 1.0
customer_waiting_time = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)']

reward_function = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

print("pickup distance: ", pickup_distance)
print("pickup_time_in_mins: ", pickup_time_in_mins)
print("delay_time_in_mins: ", delay_time_in_mins)
print("pickup_occupied_distance: ", pickup_occupied_distance)
print("pickup_occupied_CS_distance: ", pickup_occupied_CS_distance)
print("customer_waiting_time: ", customer_waiting_time)
print("reward_function: ",  reward_function)

#optimzation functions
import pandas as pd
import numpy as np
import gurobipy
from gurobipy import Model, GRB, quicksum, tuplelist
from geopy.distance import great_circle
import math
import itertools
import random
import os
import shutil
from matplotlib import pyplot as plt
from copy import deepcopy

EAV_range = 200.0 #miles
avg_speed_NYC = 13.0 #mph
power_consumption_rate = 0.3 #kWh/mi
need_charging = 0.2 #SOC<20% range
charge_upto = 0.8 #charge upto 80%

max_pickup_time = 30.0 #minutes
max_pickup_dist = max_pickup_time*avg_speed_NYC/60 #miles
max_wait_time = 15.0
charging_power = 50.0 #kW

def trip_distance(long1, lat1, long2, lat2):
  GPS1 = (long1, lat1)
  GPS2 = (long2, lat2)
  return 1.4413*great_circle(GPS1, GPS2).miles + 0.1383 #miles

taxi = pd.read_csv('taxi_data.csv')
request = pd.read_csv('customer_trip_data.csv')

taxi_index = taxi.index.tolist()
request_index = request.index.tolist()
path = tuplelist(list(itertools.product(taxi_index, request_index)))
taxi = taxi.to_dict(orient="index")
request = request.to_dict(orient="index")

#pickup distance
pickup_distance = pd.DataFrame(index=taxi_index, columns=request_index)
pickup_distance = pickup_distance.to_dict(orient="index")
for each_taxi in taxi_index:
  for each_request in request_index:
    taxi_GPS = (taxi[each_taxi]['taxi_longitude'], taxi[each_taxi]['taxi_lattitude'])
    request_GPS = (request[each_request]['pickup_longitude'], request[each_request]['pickup_lattitude'])
    pickup_distance[each_taxi][each_request] = 1.4413*great_circle(taxi_GPS, request_GPS).miles + 0.1383 #miles

#pickup time
pickup_time_in_mins = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_time_in_mins[each_taxi][each_request] = int(math.ceil((pickup_distance[each_taxi][each_request]/avg_speed_NYC) * 60))
    
#pickup time + customer_waiting_time(mins)
delay_time_in_mins = deepcopy(pickup_time_in_mins)
for each_taxi in taxi_index:
  for each_request in request_index:
    delay_time_in_mins[each_taxi][each_request] = (pickup_time_in_mins[each_taxi][each_request]
            + request[each_request]['customer_waiting_time(mins)'])
    
#pickup distance + occupied distance dictionary
pickup_occupied_distance = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_occupied_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance']
            
#pickup distance + occupied distance + charging distance dictionary
pickup_occupied_CS_distance = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    pickup_occupied_CS_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance'] + request[each_request]['CS_distance']

#customer waiting time
eta = 1.0
customer_waiting_time = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)']

reward_function = deepcopy(pickup_distance)
for each_taxi in taxi_index:
  for each_request in request_index:
    reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

model = Model()
model.setParam('OutputFlag', 0)

#variables
x = model.addVars(taxi_index, request_index, vtype=GRB.BINARY, name="x")
obj = quicksum(x[i,j]*reward_function[i][j] for i,j in path)
model.setObjective(obj, GRB.MAXIMIZE)

#add constraints
for each_taxi in taxi_index:
  for each_request in request_index:
    if (pickup_occupied_CS_distance[each_taxi][each_request]>(taxi[each_taxi]['soc']*EAV_range)):
      model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if range is not enough
    if(pickup_time_in_mins[each_taxi][each_request] > max_pickup_time):
      model.addConstr(x[each_taxi, each_request] == 0) #taxi does not accept request if pickup time is more than max
    if(customer_waiting_time[each_taxi][each_request] > max_wait_time):
      model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if waiting time is more than max

model.addConstrs(x.sum(i, '*')<=1 for i in taxi_index)
model.addConstrs(x.sum('*', j)<=1 for j in request_index)
    
#solve
model.optimize()
#print solution
for v in model.getVars():
  if v.x == 1.0:
    print(v.varName, v.x)
print('Obj:', model.objVal)

#analysis - reward fxn vs eta
eta_list = np.round_(np.arange(0, 2.1, 0.1).tolist(), decimals = 2)
obj_function_val = np.array([])

for eta in eta_list:
  customer_waiting_time = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)'] 

  reward_function = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

  model = Model()
  model.setParam('OutputFlag', 0)

  #variables
  x = model.addVars(taxi_index, request_index, vtype=GRB.BINARY, name="x")
  obj = quicksum(x[i,j]*reward_function[i][j] for i,j in path)
  model.setObjective(obj, GRB.MAXIMIZE)

  for each_taxi in taxi_index:
    for each_request in request_index:
      if (pickup_occupied_CS_distance[each_taxi][each_request]>(taxi[each_taxi]['soc']*EAV_range)):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if range is not enough
      if(pickup_time_in_mins[each_taxi][each_request] > max_pickup_time):
        model.addConstr(x[each_taxi, each_request] == 0) #taxi does not accept request if pickup time is more than max
      if(customer_waiting_time[each_taxi][each_request] > max_wait_time):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if waiting time is more than max

  model.addConstrs(x.sum(i, '*')<=1 for i in taxi_index)
  model.addConstrs(x.sum('*', j)<=1 for j in request_index)

  #solve
  model.optimize()
  # print('Obj:', model.objVal)
  obj_function_val = np.append(obj_function_val, model.objVal)

plt.plot(eta_list, obj_function_val)
plt.xlabel("customer equity trade-off")
plt.ylabel("reward function value")
plt.show()

#analysis - eta vs efficiency
eta_list = np.round_(np.arange(0, 2.1, 0.1).tolist(), decimals = 2)
efficiency = np.array([])
pickup_time = np.array([])

for eta in eta_list:
  customer_waiting_time = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)'] 

  reward_function = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

  model = Model()
  model.setParam('OutputFlag', 0)

  #variables
  x = model.addVars(taxi_index, request_index, vtype=GRB.BINARY, name="x")
  obj = quicksum(x[i,j]*reward_function[i][j] for i,j in path)
  model.setObjective(obj, GRB.MAXIMIZE)

  #add constraints
  for each_taxi in taxi_index:
    for each_request in request_index:
      if (pickup_occupied_CS_distance[each_taxi][each_request]>(taxi[each_taxi]['soc']*EAV_range)):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if range is not enough
      if(pickup_time_in_mins[each_taxi][each_request] > max_pickup_time):
        model.addConstr(x[each_taxi, each_request] == 0) #taxi does not accept request if pickup time is more than max
      # if(customer_waiting_time[each_taxi][each_request] > max_wait_time):
      #   model.addConstr(x[each_taxi, each_request]==0)

  model.addConstrs(x.sum(i, '*')<=1 for i in taxi_index)
  model.addConstrs(x.sum('*', j)<=1 for j in request_index)

  #solve
  model.optimize()
  # print('Obj:', model.objVal)

  total_pickup_time = 0.0
  for v in model.getVars():
    if v.x == 1.0:
      str = v.varName
      total_pickup_time += pickup_time_in_mins[int((str.split(',')[0]).split('[')[1])][int((str.split(',')[1]).split(']')[0])]
  
  avg_pickup_time = 0.0
  avg_pickup_time = (total_pickup_time)/(len(taxi_index))

  pickup_time = np.append(pickup_time, avg_pickup_time)

plt.plot(eta_list, pickup_time)
plt.xlabel("customer equity trade-off")
plt.ylabel("average pickup time")
plt.show()

efficiency = (1/pickup_time) * 100
plt.plot(eta_list, efficiency)
plt.xlabel("customer equity trade-off")
plt.ylabel("efficiency")
plt.show()

#analysis - gini coefficient(Lorenz Curve)
#analysis - eta vs efficiency
eta_list = np.round_(np.arange(0, 2.1, 0.1).tolist(), decimals = 2)
gini_coefficient = np.array([])

#reference: https://www.statology.org/gini-coefficient-python/
def gini(x):
    total = 0
    for i, xi in enumerate(x[:-1], 1):
        total += np.sum(np.abs(xi - x[i:]))
    return total / (len(x)**2 * np.mean(x))

for eta in eta_list:
  customer_waiting_time_distribution = np.array([])
  
  customer_waiting_time = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)'] 

  reward_function = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

  model = Model()
  model.setParam('OutputFlag', 0)

  #variables
  x = model.addVars(taxi_index, request_index, vtype=GRB.BINARY, name="x")
  obj = quicksum(x[i,j]*reward_function[i][j] for i,j in path)
  model.setObjective(obj, GRB.MAXIMIZE)

  #add constraints
  for each_taxi in taxi_index:
    for each_request in request_index:
      if (pickup_occupied_CS_distance[each_taxi][each_request]>(taxi[each_taxi]['soc']*EAV_range)):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if range is not enough
      if(pickup_time_in_mins[each_taxi][each_request] > max_pickup_time):
        model.addConstr(x[each_taxi, each_request] == 0) #taxi does not accept request if pickup time is more than max
      # if(customer_waiting_time[each_taxi][each_request] > max_wait_time):
      #   model.addConstr(x[each_taxi, each_request]==0)

  model.addConstrs(x.sum(i, '*')<=1 for i in taxi_index)
  model.addConstrs(x.sum('*', j)<=1 for j in request_index)

  #solve
  model.optimize()
  # print('Obj:', model.objVal)

  total_pickup_time = 0.0
  for v in model.getVars():
    if v.x == 1.0:
      str = v.varName
      customer_waiting_time_distribution = np.append(customer_waiting_time_distribution, customer_waiting_time[int((str.split(',')[0]).split('[')[1])][int((str.split(',')[1]).split(']')[0])])

  gini_coefficient = np.append(gini_coefficient, gini(customer_waiting_time_distribution))

plt.plot(eta_list, gini_coefficient)
plt.xlabel("customer equity trade-off")
plt.ylabel("Gini Coefficient")
plt.show()

#analysis - optimal eta with different datasets (to find the best eta)

#analysis - variation of objective fuction value with different data at optimal eta
import pandas as pd
import numpy as np
import gurobipy
from gurobipy import Model, GRB, quicksum, tuplelist
from geopy.distance import great_circle
import math
import itertools
import random
import os
import shutil
from matplotlib import pyplot as plt
from copy import deepcopy

EAV_range = 200.0 #miles
avg_speed_NYC = 13.0 #mph
power_consumption_rate = 0.3 #kWh/mi
need_charging = 0.2 #SOC<20% range
charge_upto = 0.8 #charge upto 80%

max_pickup_time = 30.0 #minutes
max_pickup_dist = max_pickup_time*avg_speed_NYC/60 #miles
max_wait_time = 15.0
charging_power = 50.0 #kW

def trip_distance(long1, lat1, long2, lat2):
  GPS1 = (long1, lat1)
  GPS2 = (long2, lat2)
  return 1.4413*great_circle(GPS1, GPS2).miles + 0.1383 #miles

eta = 1.0
obj_function_val = np.array([])
for i in range(1):
  taxi = pd.read_csv(f'taxi_data{i}.csv')
  request = pd.read_csv(f'customer_trip_data{i}.csv')

  taxi_index = taxi.index.tolist()
  request_index = request.index.tolist()
  path = tuplelist(list(itertools.product(taxi_index, request_index)))
  taxi = taxi.to_dict(orient="index")
  request = request.to_dict(orient="index")

  #pickup distance
  pickup_distance = pd.DataFrame(index=taxi_index, columns=request_index)
  pickup_distance = pickup_distance.to_dict(orient="index")
  for each_taxi in taxi_index:
    for each_request in request_index:
      taxi_GPS = (taxi[each_taxi]['taxi_longitude'], taxi[each_taxi]['taxi_lattitude'])
      request_GPS = (request[each_request]['pickup_longitude'], request[each_request]['pickup_lattitude'])
      pickup_distance[each_taxi][each_request] = 1.4413*great_circle(taxi_GPS, request_GPS).miles + 0.1383 #miles

  #pickup time
  pickup_time_in_mins = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      pickup_time_in_mins[each_taxi][each_request] = int(math.ceil((pickup_distance[each_taxi][each_request]/avg_speed_NYC) * 60))
      
  #pickup time + customer_waiting_time(mins)
  delay_time_in_mins = deepcopy(pickup_time_in_mins)
  for each_taxi in taxi_index:
    for each_request in request_index:
      delay_time_in_mins[each_taxi][each_request] = (pickup_time_in_mins[each_taxi][each_request]
              + request[each_request]['customer_waiting_time(mins)'])
      
  #pickup distance + occupied distance dictionary
  pickup_occupied_distance = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      pickup_occupied_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance']
              
  #pickup distance + occupied distance + charging distance dictionary
  pickup_occupied_CS_distance = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      pickup_occupied_CS_distance[each_taxi][each_request] = pickup_distance[each_taxi][each_request] + request[each_request]['trip_distance'] + request[each_request]['CS_distance']

  #customer waiting time
  customer_waiting_time = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      customer_waiting_time[each_taxi][each_request] = eta*request[each_request]['customer_waiting_time(mins)']

  reward_function = deepcopy(pickup_distance)
  for each_taxi in taxi_index:
    for each_request in request_index:
      reward_function[each_taxi][each_request] = max_pickup_time - pickup_time_in_mins[each_taxi][each_request] + customer_waiting_time[each_taxi][each_request]

  model = Model()
  model.setParam('OutputFlag', 0)

  #variables
  x = model.addVars(taxi_index, request_index, vtype=GRB.BINARY, name="x")
  obj = quicksum(x[i,j]*reward_function[i][j] for i,j in path)
  model.setObjective(obj, GRB.MAXIMIZE)

  #add constraints
  for each_taxi in taxi_index:
    for each_request in request_index:
      if (pickup_occupied_CS_distance[each_taxi][each_request]>(taxi[each_taxi]['soc']*EAV_range)):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if range is not enough
      if(pickup_time_in_mins[each_taxi][each_request] > max_pickup_time):
        model.addConstr(x[each_taxi, each_request] == 0) #taxi does not accept request if pickup time is more than max
      if(customer_waiting_time[each_taxi][each_request] > max_wait_time):
        model.addConstr(x[each_taxi, each_request]==0) #taxi does not accept request if waiting time is more than max

  model.addConstrs(x.sum(i, '*')<=1 for i in taxi_index)
  model.addConstrs(x.sum('*', j)<=1 for j in request_index)
      
  #solve
  model.optimize()
  print('Obj:', model.objVal)
  obj_function_val = np.append(obj_function_val, model.objVal)

print(obj_function_val)

import pandas as pd
import numpy as np
from geopy.distance import great_circle
import random
def trip_distance(long1, lat1, long2, lat2):
  GPS1 = (long1, lat1)
  GPS2 = (long2, lat2)
  return 1.4413*great_circle(GPS1, GPS2).miles + 0.1383 #miles

request = pd.read_csv('customer_trip_data.csv')
request_index = request.index.tolist()
cs_min = 0.2
cs_max = 1.2
cw_min = 1
cw_max = 20
for index in request_index:
  request.loc[index,'trip_distance'] = round(trip_distance(request['pickup_longitude'][index], request['pickup_lattitude'][index], 
                                                     request['dropoff_longitude'][index], request['dropoff_lattitude'][index]), 3)
  request.loc[index, 'CS_distance'] = round(cs_min + (cs_max - cs_min)*random.random(), 3)
  request.loc[index,'customer_waiting_time(mins)'] = round(cw_min + (cw_max - cw_min)*random.random(),1)
request.to_csv('customer_trip_data.csv', index = False)


taxi = pd.read_csv('taxi_data.csv')
taxi_index = taxi.index.tolist()
soc_min = 0.1
soc_max = 1.0

for index in taxi_index:
  taxi.loc[index, 'soc'] = round(soc_min + (soc_max - soc_min)*random.random(), 2)
taxi.to_csv('taxi_data.csv', index = False)

import pandas as pd
import numpy as np
from geopy.distance import great_circle
import random
def trip_distance(long1, lat1, long2, lat2):
  GPS1 = (long1, lat1)
  GPS2 = (long2, lat2)
  return 1.4413*great_circle(GPS1, GPS2).miles + 0.1383 #miles

request = pd.read_csv('trip_data_3.csv')
request_index = request.index.tolist()
cs_min = 0.2
cs_max = 1.2
cw_min = 1
cw_max = 20
for index in request_index:
  request.loc[index,'trip_distance'] = round(trip_distance(request['pickup_longitude'][index], request['pickup_lattitude'][index], 
                                                     request['dropoff_longitude'][index], request['dropoff_lattitude'][index]), 3)
  request.loc[index, 'CS_distance'] = round(cs_min + (cs_max - cs_min)*random.random(), 3)
  request.loc[index,'customer_waiting_time(mins)'] = round(cw_min + (cw_max - cw_min)*random.random(),1)
request.to_csv('customer_trip_data.csv', index = False)


taxi = pd.read_csv('taxi_data.csv')
taxi_index = taxi.index.tolist()
soc_min = 0.1
soc_max = 1.0

for index in taxi_index:
  taxi.loc[index, 'soc'] = round(soc_min + (soc_max - soc_min)*random.random(), 2)
taxi.to_csv('taxi_data.csv', index = False)

import numpy as np
import matplotlib.pyplot as plt
 
# Dataset
x = np.array([ 1,  2,  3,  4,  5,  6,  7, 8 ])
y = np.array([ 20, 30, 5, 12, 39, 48, 50, 3 ])
 
# Plotting the Graph
plt.plot(x, y)
plt.title("Curve plotted using the given points")
plt.xlabel("X")
plt.ylabel("Y")
plt.show()

str = "x[0,3]"
taxi = int((str.split(',')[0]).split('[')[1])
print(taxi)
request = int((str.split(',')[1]).split(']')[0])
print(request)

print(type(taxi))
print(type(request))
print(taxi * request)

# total_pickup_time += pickup_time_in_mins[int((v.varName.split(',')[0]).split('[')[1]), int((v.varName.split(',')[1]).split(']')[0])]

